diff --git a/CMakeLists.txt b/CMakeLists.txt
index e8cc311..29bb63f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -14,42 +14,27 @@ project(BlockSQP_2
 set(CMAKE_CXX_STANDARD 20)
 enable_language(Fortran)	#For MUMPS linear solver
 
+
 #Static linking to avoid having to copy dll(-path)s.
 if(WIN32)
-	if(NOT MSVC)
-		message(FATAL_ERROR "This CMakeLists supports building on windows only with MSVC and intel oneAPI fortran")
+	set(BLA_VENDOR OpenBLAS)
+	set(LAPACK_VENDOR OpenBLAS)
+	set(BLA_STATIC OFF)
+	
+	set(OPENBLAS_DIR "" CACHE STRING "Path to the OpenBLAS installation folder containing lib, bin and include folders. Make sure it is the 32bit-integer version (e.g. Openblas-*.*.**-x64)")
+	if (OPENBLAS_DIR STREQUAL "")
+		message(FATAL_ERROR "\nERROR: Please pass path to OpenBLAS via cmake -B build ... -DOPENBLAS_DIR=\"PATH/TO/OPENBLAS\". The folder should contain lib, bin and include folders. Make sure it is the 32bit-integer version (e.g. Openblas-*.*.**-x64)")
 	endif()
-	set(INTEL_STATIC_LINK_FLAGS "-static-intel")
-	add_compile_options(/MT)
-
-	set(BLA_STATIC ON)
-	set(BLA_VENDOR Intel10_64lp_seq)
+	file(TO_CMAKE_PATH ${OPENBLAS_DIR} OPENBLAS_DIR)
+	set(CMAKE_PREFIX_PATH ${OPENBLAS_DIR})
+	set(OPENBLAS_INCLUDE_DIR ${OPENBLAS_DIR}/include ${OPENBLAS_DIR}/include/openblas)
 endif()
 
-#Uncomment to manually find blas, also uncomment BLA_VENDOR Intel... above
-#[[
-set(BLA_STATIC ON)
-set(BLA_VENDOR Intel10_64lp_seq)
-find_package(BLAS REQUIRED)
-find_package(LAPACK REQUIRED)
-message(STATUS "BLAS_FOUND = ${BLAS_FOUND}")
-message(STATUS "BLAS_LIBRARIES = ${BLAS_LIBRARIES}")
-message(STATUS "BLAS_LINKER_FLAGS = ${BLAS_LINKER_FLAGS}")
-message(STATUS "LAPACK_LIBRARIES = ${LAPACK_LIBRARIES}")
-
-#NOTE: Set LAPACK_LIBRARY beforehand to force CMakeMumps to use that LAPACK_LIBRARY. Dont forget to link BLAS
-set(BLAS_LIBRARY ${BLAS_LIBRARIES})
-set(LAPACK_LIBRARY ${LAPACK_LIBRARIES})
-]]
-
-
 find_package(BLAS REQUIRED)
 message(STATUS "BLAS_FOUND = ${BLAS_FOUND}")
 message(STATUS "BLAS_LIBRARIES = ${BLAS_LIBRARIES}")
-message(STATUS "BLAS_LINKER_FLAGS = ${BLAS_LINKER_FLAGS}")
 find_package(LAPACK REQUIRED)
 message(STATUS "LAPACK_LIBRARIES = ${LAPACK_LIBRARIES}")
-message(STATUS "LAPACK_LINKER_FLAGS = ${LAPACK_LINKER_FLAGS}")
 set(BLAS_LIBRARY ${BLAS_LIBRARIES})
 set(LAPACK_LIBRARY ${LAPACK_LIBRARIES})
 
@@ -58,29 +43,28 @@ FetchContent_Declare(
 	CMAKEMUMPS
 	GIT_REPOSITORY https://github.com/scivision/mumps.git
 	GIT_TAG 5b153379cdd1b0d2a33daf88bffab16a22ff0004
-	#GIT_TAG e583b83d41823759c83403217d9e3713eedc60e4
 )
 set(MUMPS_parallel OFF)
 set(MUMPS_scalapack OFF)
 set(BUILD_SINGLE OFF)
 
-
 if(WIN32)
-	set(MUMPS_find_static ON)
+	set(MUMPS_find_static OFF)
 	set(MUMPS_openmp OFF)
-	set(CMAKE_Fortran_FLAGS ${CMAKE_Fortran_FLAGS} /Os)
+	set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -Os")
 else()
 	set(MUMPS_find_static OFF)
 	set(CMAKE_Fortran_FLAGS ${CMAKE_Fortran_FLAGS} -Os) #Likely to be loaded several times with dlmopen + no noticeable performance difference compared to -O3
 endif()
-set(MUMPS_intsize64 OFF) #must be off
+set(MUMPS_intsize64 OFF) #We use 32bit-integer BLAS, so this must be OFF
 
-#Shared MUMPS libraries are not supported when building with oneAPI and MSVC on windows
-# + a separate shared library may need to be built from this, so default to static
+#Default to static, since we later build a shared library from this
 set(BUILD_SHARED_LIBS OFF)
 
 FetchContent_MakeAvailable(CMAKEMUMPS)
+
 #############################################################
+#Build instuction for contained files
 
 set(qpOASES_MODDED_DIR ${CMAKE_CURRENT_SOURCE_DIR}/blockSQP/dep/modified_qpOASES)
 add_library(qpOASES STATIC
@@ -104,7 +88,7 @@ add_library(qpOASES STATIC
 
 #MUMPS LINEAR SOLVER
 target_compile_definitions(qpOASES PUBLIC SOLVER_MUMPS PRIVATE MUMPS_SEQ __NO_COPYRIGHT__)
-target_link_libraries(qpOASES PUBLIC MUMPS::MUMPS) #LAPACK::LAPACK BLAS::BLAS) #
+target_link_libraries(qpOASES PUBLIC MUMPS::MUMPS LAPACK::LAPACK BLAS::BLAS) #
 IF(UNIX)
 	target_compile_definitions(qpOASES PRIVATE LINUX)
 	target_compile_options(qpOASES PUBLIC -fPIC PRIVATE -O3 INTERFACE -Wno-overloaded-virtual)
@@ -112,7 +96,13 @@ IF(UNIX)
 		target_link_libraries(qpOASES PUBLIC -lgfortran)
 	endif()
 ELSEIF(WIN32)
-    target_compile_options(qpOASES PRIVATE -nologo -EHsc -DWIN32)
+    #target_compile_options(qpOASES PRIVATE -nologo -EHsc -DWIN32)
+	if(MINGW)
+		target_compile_options(qpOASES PRIVATE -DWIN32 
+			-Wall -pedantic -Wfloat-equal -Wshadow 
+			-O3 -finline-functions
+		)
+	endif()
 ENDIF()
 target_include_directories(qpOASES
 	PUBLIC	${qpOASES_MODDED_DIR}/include
@@ -170,7 +160,6 @@ target_include_directories(qpOASES
 ]]
 
 
-
 #MA57 LINEAR SOLVER
 ## Build qpOASES with MA57, requires passing preprocessor flag -DSOLVER_MA57
 ## Dependencies are -> METIS -> GKLIB, LAPACK, BLAS, dl
@@ -193,8 +182,8 @@ target_include_directories(qpOASES
 
 
 
-#As of right now, there are no export specifications ( __declspec((dllexport)), __attribute__((visibility("default"))) )
-#in the code, so static linking is recommended
+#As of right now, there are no export specifications ( __declspec(dllexport), __attribute__((visibility("default"))) )
+#in the code, so static linking is recommended.
 add_library(blockSQP STATIC
 	blockSQP/src/blocksqp_condensing.cpp
 	blockSQP/src/blocksqp_matrix.cpp
@@ -227,43 +216,61 @@ if (UNIX)
 		-O3
 		# -DMATRIX_DEBUG		#Enable bounds and dimension checks for matrix operations
 		)
-	
 elseif(WIN32)
 	target_compile_definitions(blockSQP PUBLIC WINDOWS)
+	if(MINGW)
+		target_compile_options(blockSQP PRIVATE 
+			-Wall -Wextra -Wno-unused-parameter -Wno-maybe-uninitialized
+			-O3
+			# -DMATRIX_DEBUG		#Enable bounds and dimension checks for matrix operations
+			)
+	endif()
 endif()
 
-
-
 set_target_properties(blockSQP PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/blockSQP/bin
 										  ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/blockSQP/lib
 										  RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/blockSQP/bin)
 
-target_include_directories(blockSQP PUBLIC blockSQP/include ${qpOASES_MODDED_DIR}/include ${qpOASES_MODDED_DIR}/include/qpOASES)
+target_include_directories(blockSQP PUBLIC blockSQP/include ${qpOASES_MODDED_DIR}/include ${qpOASES_MODDED_DIR}/include/qpOASES ${OPENBLAS_INCLUDE_DIR})
 target_link_libraries(blockSQP PUBLIC qpOASES) #Important: If qpOASES is built with MUMPS, -DSOLVER_MUMPS must be inherited
 											   #		   to enable workarounds for MUMPS not being thread safe,
 											   #		   or prevent MUMPS from running in parallel
 
 #Shared mumps library/libraries for dynamic loading in a threadsafe way (dlmopen on linux, LoadLibraryA on multiple copies on windows, tough luck on mac)
+#Also attach copying of dlls here since we copy dmumps_c_dyn anyways.
+set(COPY_COUNTER 0)
 if (UNIX AND NOT APPLE)
 	add_library(dmumps_c_dyn SHARED blockSQP/src/ext/dmumps_c_dyn.cpp)
 	set_target_properties(dmumps_c_dyn PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/blockSQP/bin
-												ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/blockSQP/lib
-												RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/blockSQP/bin)
+												  ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/blockSQP/lib
+												  RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/blockSQP/bin)
 	target_link_libraries(dmumps_c_dyn PRIVATE MUMPS::MUMPS)
 	target_compile_options(dmumps_c_dyn PRIVATE -O3 -fvisibility=hidden)
-	#Notify downstream libraries that dmumps_c_dyn will be made available through LDMUMPS_C_DYN compile flag
-	#As of right now, this is only used on linux
-	# target_compile_definitions(dmumps_c_dyn INTERFACE DMUMPS_C_DYN)
-	# target_link_libraries(blockSQP PUBLIC dmumps_c_dyn)
-	
-	
-	function(maybe_copy_mumps_libs LIBPATH)
+
+	function(copy_dynamic_libraries_to LIBPATH)
+		#[[
 		set(mumps_lib dmumps_c_dyn)
 		add_custom_command(TARGET ${mumps_lib} POST_BUILD
 			COMMAND ${CMAKE_COMMAND} -E copy_if_different
 					${CMAKE_SOURCE_DIR}/blockSQP/bin/lib${mumps_lib}.so
 					${LIBPATH}
 		)
+		]]
+
+		set(MUMPS_COPY_TARGET MCT_${COPY_COUNTER})
+		MATH(EXPR COPY_COUNTER_LOCAL "${COPY_COUNTER} + 1")
+		set(COPY_COUNTER ${COPY_COUNTER_LOCAL} PARENT_SCOPE)
+
+		add_custom_target(${MUMPS_COPY_TARGET} ALL
+<<<<<<< HEAD
+			COMMAND ${CMAKE_COMMAND} -E copy_if_different ${CMAKE_SOURCE_DIR}/blockSQP/bin/libdmumps_c_dyn.so ${LIBPATH}
+=======
+			COMMAND ${CMAKE_COMMAND} -E copy_if_different ${CMAKE_SOURCE_DIR}/blockSQP/bin/dmumps_c_dyn.so ${LIBPATH}
+>>>>>>> 8ec9280091ae22946b043de0d110c2797171314a
+			COMMENT "Copying dynamic libraries\n"
+		)
+
+		add_dependencies(${MUMPS_COPY_TARGET} dmumps_c_dyn)
 	endfunction()
 elseif(WIN32)	
 	add_library(dmumps_c_dyn SHARED blockSQP/src/ext/dmumps_c_dyn.cpp)
@@ -272,28 +279,87 @@ elseif(WIN32)
 		ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/blockSQP/lib
 		RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/blockSQP/bin)
 	target_link_libraries(dmumps_c_dyn PRIVATE MUMPS::MUMPS)
+	
+	if(MINGW)
+		target_link_libraries(dmumps_c_dyn PRIVATE -static)
+		target_compile_options(dmumps_c_dyn PRIVATE -O3 -fvisibility=hidden)
+	endif()
 	target_compile_definitions(dmumps_c_dyn PRIVATE WINDOWS)
-		
-	function(maybe_copy_mumps_libs LIBPATH)
+
+	#In case of dynamic linking of libgfortran, libwinpthread, libstdc++ etc., search for them in the gcc folder
+	#Save them in a variable so they get copied to executable requiring them
+	#[[
+	execute_process(
+		COMMAND where gcc.exe
+		OUTPUT_VARIABLE GCC_PATH
+		RESULT_VARIABLE GCC_ERROR
+		OUTPUT_STRIP_TRAILING_WHITESPACE
+	)
+	if (GCC_ERROR)
+		message(FATAL_ERROR "gcc.exe not found on PATH!")
+	endif()
+
+	string(REPLACE "\r" "" GCC_PATH "${GCC_PATH}")
+	string(REGEX MATCH "^[^\n]*" GCC_PATH "${GCC_PATH}")
+
+	message(STATUS "Found gcc at: ${GCC_PATH}.")
+	get_filename_component(GCC_BIN_DIR "${GCC_PATH}" DIRECTORY)
+	
+	if(NOT EXISTS ${GCC_BIN_DIR}/libstdc++-6.dll OR NOT EXISTS ${GCC_BIN_DIR}/libgfortran-5.dll OR NOT EXISTS ${GCC_BIN_DIR}/libgcc_s_seh-1.dll OR NOT EXISTS ${GCC_BIN_DIR}/libwinpthread-1.dll OR NOT EXISTS ${GCC_BIN_DIR}/libquadmath-0.dll)
+		message(FATAL_ERROR "Could not find one of libstdc++-6.dll, libgfortran.dll, libgcc_s_seh-1.dll, libwinpthread-1.dll, libquadmath-0.dll in ${GCC_BIN_DIR}")
+	endif()
+	set(STDLIB_BINARIES ${GCC_BIN_DIR}/libstdc++-6.dll ${GCC_BIN_DIR}/libgfortran-5.dll ${GCC_BIN_DIR}/libgcc_s_seh-1.dll ${GCC_BIN_DIR}/libwinpthread-1.dll ${GCC_BIN_DIR}/libquadmath-0.dll)
+	]]
+
+	set(OPENBLAS_BINARY ${OPENBLAS_DIR}/bin/libopenblas.dll)
+	if(NOT EXISTS ${OPENBLAS_BINARY})
+		message(FATAL_ERROR "Expected libopenblas.dll in OPENBLAS_DIR/bin")
+	endif()
+
+	function(copy_dynamic_libraries_to LIBPATH)
+		set(COPY_COMMANDS)
+
+		##Mumps libraries for dynamic loading
 		foreach(i RANGE 0 7)
-			set(mumps_copy ${LIBPATH}/dmumps_c_dyn_${i}.dll)
-			add_custom_command(TARGET dmumps_c_dyn POST_BUILD
-				COMMAND ${CMAKE_COMMAND} -E copy_if_different
-						${CMAKE_SOURCE_DIR}/blockSQP/bin/dmumps_c_dyn.dll
-						${mumps_copy}
-				COMMENT "Copying dmumps_c_dyn\n"
+			set(MUMPS_COPY_PRODUCT ${LIBPATH}/dmumps_c_dyn_${i}.dll)
+			list(APPEND COPY_COMMANDS 
+				COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_SOURCE_DIR}/blockSQP/bin/libdmumps_c_dyn.dll ${MUMPS_COPY_PRODUCT}
 			)
 		endforeach()
+
+		##OpenBLAS
+		list(APPEND COPY_COMMANDS
+				COMMAND ${CMAKE_COMMAND} -E copy_if_different ${OPENBLAS_DIR}/bin/libopenblas.dll ${LIBPATH}
+			)
+		
+		##C/C++/Fortran etc. standard libraries
+		if (STDLIB_BINARIES)
+			list(APPEND COPY_COMMANDS
+				COMMAND ${CMAKE_COMMAND} -E copy_if_different ${STDLIB_BINARIES} ${LIBPATH}
+			)
+		endif()
+
+		set(MUMPS_COPY_TARGET MCT_${COPY_COUNTER})
+		MATH(EXPR COPY_COUNTER_LOCAL "${COPY_COUNTER} + 1")
+		set(COPY_COUNTER ${COPY_COUNTER_LOCAL} PARENT_SCOPE)
+
+		add_custom_target(${MUMPS_COPY_TARGET} ALL
+						  ${COPY_COMMANDS}
+						  COMMENT "Copying dynamic libraries\n"
+		)
+
+		add_dependencies(${MUMPS_COPY_TARGET} dmumps_c_dyn)
 	endfunction()
-	
 else()
-	function(maybe_copy_mumps_libs LIBPATH)
+	function(copy_dynamic_libraries_to LIBPATH)
 	endfunction()
 endif()
 
 #Mumps dynamic libraries are available. Set corresponding preprocessor flag
 target_compile_definitions(blockSQP PRIVATE DMUMPS_C_DYN)
-maybe_copy_mumps_libs(${CMAKE_SOURCE_DIR}/blockSQP/examples/bin)
+
+#Build examples and place executables and required libraries in dedicated folder
+copy_dynamic_libraries_to(${CMAKE_SOURCE_DIR}/blockSQP/examples/bin)
 
 add_executable(example1 blockSQP/examples/example1.cpp)
 target_link_libraries(example1 blockSQP)
@@ -343,22 +409,31 @@ if(PYTHON_INTERFACE)
 		#Prevent warnings for *_pointer_interface and T_array constructors 
 		#that occur after compiling with -O3. Result of using int instead of size_t, should not cause any problems.
 		target_link_options(py_blockSQP PRIVATE -Wno-alloc-size-larger-than)
+	elseif(MINGW)
+		target_compile_options(py_blockSQP PRIVATE 
+					-Wall -Wextra -Wno-unused-parameter
+					-fvisibility=hidden
+					-O3
+					)
+		target_link_options(py_blockSQP PRIVATE -Wno-alloc-size-larger-than)
 	endif()
 	
 	target_link_libraries(py_blockSQP PUBLIC blockSQP)
-	
+
+	if(MINGW)
+		target_link_libraries(py_blockSQP PRIVATE -static)
+	endif()
+
 	set(py_blockSQP_DIR ${CMAKE_SOURCE_DIR}/py_blockSQP)
 	set_target_properties(py_blockSQP PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${py_blockSQP_DIR}
 												 RUNTIME_OUTPUT_DIRECTORY ${py_blockSQP_DIR}
 												 )
-	maybe_copy_mumps_libs(${py_blockSQP_DIR})
+	copy_dynamic_libraries_to(${py_blockSQP_DIR})
 endif()
 
 
 #Build C interface to complete blockSQP.jl
-option(JULIA_INTERFACE "build julia interface" ON)
-set(CXXWRAP_PATH "" CACHE STRING "Path to CxxWrap artifact libcxxwrap-julia (default: empty)")
-
+option(JULIA_INTERFACE "build Julia interface" ON)
 if(JULIA_INTERFACE)
 	add_library(blockSQP_jl SHARED C_blockSQP/C_blockSQP.cpp)
 	target_link_libraries(blockSQP_jl PUBLIC blockSQP)
@@ -370,12 +445,19 @@ if(JULIA_INTERFACE)
 					-fvisibility=hidden
 					-O3
 					)
+	elseif(MINGW)
+		target_compile_options(blockSQP_jl PRIVATE 
+					-Wall -Wextra -Wno-unused-parameter
+					-fvisibility=hidden
+					-O3
+					)
+		target_link_libraries(blockSQP_jl PRIVATE -static)
 	endif()
 	set_target_properties(blockSQP_jl PROPERTIES 
 			PREFIX lib
 			LIBRARY_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/blockSQP.jl/bin
 			RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/blockSQP.jl/bin
 	)
-	maybe_copy_mumps_libs(${CMAKE_SOURCE_DIR}/blockSQP.jl/bin)
+	copy_dynamic_libraries_to(${CMAKE_SOURCE_DIR}/blockSQP.jl/bin)
 endif()
 
diff --git a/README.md b/README.md
index 07f5ac8..acf5f72 100644
--- a/README.md
+++ b/README.md
@@ -5,7 +5,7 @@ Copyright (c) 2023-2025 Reinhold Wittmann <reinhold.wittmann@ovgu.de>
 Part of blockSQP 2 is **py_blockSQP** -- A python interface to blockSQP 2,  
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the nonlinear programming solver based on blockSQP by Dennis Janka.
 
-###Licensing
+### Licensing
 blockSQP 2 preserves the zlib license of blockSQP, see LICENSE.txt and blockSQP/LICENSE.txt.  
   
 This project includes a modified version of qpOASES <https://github.com/coin-or/qpOASES>, located in blockSQP/dep and subject to a separate LGPL-2.1 license, see blockSQP/dep/modified_qpOASES/LICENSE.txt  
@@ -15,50 +15,66 @@ When building this project with CMake, the following dependencies are downloaded
 2. MUMPS-CMake build system <https://github.com/scivision/mumps> (MIT license)  
 3. pybind11 <https://github.com/pybind/pybind11> (custom license)  
   
-Each license applies to the respective package, and any statement in it regarding compiled code applies to binary files produced by this projects build system that include that compiled code.
-
-
-#Build requirements
+Each license applies to the respective package, and any statement in it regarding compiled code applies to binary files produced by this projects build system that include that compiled code. In addition, BLAS and LAPACK libraries may be linked to or included, e.g. OpenBLAS (BSD-3-Clause license) <https://github.com/OpenMathLib/OpenBLAS.
+
+
+<<<<<<< HEAD
+<<<<<<< HEAD
+### Build requirements
+=======
+# Build requirements
+>>>>>>> 8ec9280091ae22946b043de0d110c2797171314a
+=======
+# Build requirements
+>>>>>>> 8ec9280091ae22946b043de0d110c2797171314a
 1. A Fortran compiler, e.g. gfortran
 2. A C++-20 compatible C++ compiler, e.g. g++-14
 3. The CMake build system <https://cmake.org/>
 4. A build system backend (GNU make, Ninja build)
 
-##Building
+## Building
 Build by calling:  
-&nbsp;&nbsp; cmake -B .build ${OPTIONS}  
-&nbsp;&nbsp; cmake --build .build
+&nbsp;&nbsp; `cmake -B .build ${OPTIONS}`  
+&nbsp;&nbsp; `cmake --build .build`
 
-###General build options
-1. -DCMAKE_Fortran_COMPILER=... - choose the Fortran compiler
-2. -DCMAKE_CXX_COMPILER=... - choose the C++ compiler
-3. -G ("Unix Makefiles" / Ninja) - choose the build system backend
+### General build options
+1. `-DCMAKE_Fortran_COMPILER=...` - choose the Fortran compiler
+2. `-DCMAKE_CXX_COMPILER=...` - choose the C++ compiler
+3. `-G` ("Unix Makefiles" / Ninja) - choose the build system backend
 
-###blockSQP build options
-1. -DPYTHON_INTERFACE= (ON/OFF) - build py_blockSQP, default ON
-2. -DPYTHON_INTERPRETER= (/PATH/TO/PYTHON_EXECUTABLE) - optional, choose python interpreter to build for
-3. -DJULIA_INTERFACE= (ON/OFF) - build blocksqp.jl from the C interface, default ON
+### blockSQP build options
+1. `-DPYTHON_INTERFACE= (ON/OFF)` - build py_blockSQP, default ON
+2. `-DPYTHON_INTERPRETER= (/PATH/TO/PYTHON_EXECUTABLE)` - optional, choose python interpreter to build for
+3. `-DJULIA_INTERFACE= (ON/OFF)` - build blocksqp.jl from the C interface, default ON
 
 See README_WINDOWS.md on how to build for windows with MSVC and intel Fortran.
 
-###Binaries
+### Binaries
 The binaries are placed into /blockSQP/lib or /blockSQP/bin, /py_blockSQP and /blocksqp.jl/bin. 
 
-##Examples and documentation
+## Examples and documentation
 
-###Python interface requirements
+### Python interface requirements
 The py_blockSQP requires numpy, running the Python scripts additionally requires casadi and matplotlib. The project was tested for numpy 2.3.2, casadi 3.7.1 and matplotlib 3.10.5.  
 In addition, some plot functions require LaTeX to be available on the system.
 
-##Testing and benchmarking
+<<<<<<< HEAD
+<<<<<<< HEAD
+### Testing and benchmarking
+=======
+## Testing and benchmarking
+>>>>>>> 8ec9280091ae22946b043de0d110c2797171314a
+=======
+## Testing and benchmarking
+>>>>>>> 8ec9280091ae22946b043de0d110c2797171314a
 Run benchmark/run_blockSQP.py to confirm the solver was built correctly.  
 Edit the script to select various example problems and options.  
 
 The script benchmark/experiments/run_blockSQP_experiments.py can be used to benchmark blockSQP on several problems for perturbed start point for different options.
 
-###C++ and Julia examples
+### C++ and Julia examples
 C++ examples are located in blockSQP/examples, the example executables are placed into blockSQP/examples/bin.  
 
-If blockSQP.jl was built, julia examples are located at blocksqp.jl/scripts.  
+If blockSQP.jl was built, Julia examples are located at blocksqp.jl/scripts.  
 Tests can be run after installing the dependencies specified in the project.toml
 
diff --git a/README_.md b/README_.md
new file mode 100644
index 0000000..ee00dbc
--- /dev/null
+++ b/README_.md
@@ -0,0 +1,64 @@
+**blockSQP 2** -- Condensing, convexification strategies, scaling heuristics and more  
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for blockSQP, the nonlinear programming solver by Dennis Janka.  
+Copyright (c) 2023-2025 Reinhold Wittmann <reinhold.wittmann@ovgu.de>  
+
+Part of blockSQP 2 is **py_blockSQP** -- A python interface to blockSQP 2,  
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the nonlinear programming solver based on blockSQP by Dennis Janka.
+
+### Licensing
+blockSQP 2 preserves the zlib license of blockSQP, see LICENSE.txt and blockSQP/LICENSE.txt.  
+  
+This project includes a modified version of qpOASES <https://github.com/coin-or/qpOASES>, located in blockSQP/dep and subject to a separate LGPL-2.1 license, see blockSQP/dep/modified_qpOASES/LICENSE.txt  
+
+When building this project with CMake, the following dependencies are downloaded.  
+1. MUMPS <https://mumps-solver.org/index.php?page=home> (CeCILL-C license)  
+2. MUMPS-CMake build system <https://github.com/scivision/mumps> (MIT license)  
+3. pybind11 <https://github.com/pybind/pybind11> (custom license)  
+  
+Each license applies to the respective package, and any statement in it regarding compiled code applies to binary files produced by this projects build system that include that compiled code.
+
+
+# Build requirements
+1. A Fortran compiler, e.g. gfortran
+2. A C++-20 compatible C++ compiler, e.g. g++-14
+3. The CMake build system <https://cmake.org/>
+4. A build system backend (GNU make, Ninja build)
+
+## Building
+Build by calling:  
+&nbsp;&nbsp; `cmake -B .build ${OPTIONS}`  
+&nbsp;&nbsp; `cmake --build .build`
+
+### General build options
+1. `-DCMAKE_Fortran_COMPILER=...` - choose the Fortran compiler
+2. `-DCMAKE_CXX_COMPILER=...` - choose the C++ compiler
+3. `-G` ("Unix Makefiles" / Ninja) - choose the build system backend
+
+### blockSQP build options
+1. `-DPYTHON_INTERFACE= (ON/OFF)` - build py_blockSQP, default ON
+2. `-DPYTHON_INTERPRETER= (/PATH/TO/PYTHON_EXECUTABLE)` - optional, choose python interpreter to build for
+3. `-DJULIA_INTERFACE= (ON/OFF)` - build blocksqp.jl from the C interface, default ON
+
+See README_WINDOWS.md on how to build for windows with MSVC and intel Fortran.
+
+### Binaries
+The binaries are placed into /blockSQP/lib or /blockSQP/bin, /py_blockSQP and /blocksqp.jl/bin. 
+
+## Examples and documentation
+
+### Python interface requirements
+The py_blockSQP requires numpy, running the Python scripts additionally requires casadi and matplotlib. The project was tested for numpy 2.3.2, casadi 3.7.1 and matplotlib 3.10.5.  
+In addition, some plot functions require LaTeX to be available on the system.
+
+## Testing and benchmarking
+Run benchmark/run_blockSQP.py to confirm the solver was built correctly.  
+Edit the script to select various example problems and options.  
+
+The script benchmark/experiments/run_blockSQP_experiments.py can be used to benchmark blockSQP on several problems for perturbed start point for different options.
+
+### C++ and Julia examples
+C++ examples are located in blockSQP/examples, the example executables are placed into blockSQP/examples/bin.  
+
+If blockSQP.jl was built, julia examples are located at blocksqp.jl/scripts.  
+Tests can be run after installing the dependencies specified in the project.toml
+
diff --git a/README_windows.md b/README_windows.md
index 0bcd938..964b68e 100644
--- a/README_windows.md
+++ b/README_windows.md
@@ -8,27 +8,26 @@ The following configuration is known to work for building blockSQP 2 on Windows.
 
 ### Requirements:
 - CMake build system (<https://cmake.org/download/>).
-- Ninja build system backend (<https://github.com/ninja-build/ninja/releases>). Make sure the executable it is in the search path, adapt "PATH" in the environment variables or later add -DCMAKE_MAKE_PROGRAM=/PATH/TO/ninja.exe in the build step
-- MSVC C++ compiler (included in Visual Studio Community 2022)
-- Intel Fortran compiler and intel oneMKL from the intel oneAPI HPC Toolkit (<https://www.intel.com/content/www/us/en/developer/tools/oneapi/hpc-toolkit-download.html>)
+- Ninja build system backend (<https://github.com/ninja-build/ninja/releases>). Make sure the executable it is in the search path i.e. add it to "Path" in the environment variables or later add -DCMAKE_MAKE_PROGRAM=/PATH/TO/ninja.exe in the build step  
+- The mingw- gcc, g++ and gfortran compilers from <https://www.mingw-w64.org/>. The x86_64-15.2.0-release-posix-seh-ucrt-rt_v13-rev0 variant from <https://github.com/niXman/mingw-builds-binaries/releases> is recommended. 
+Make sure the folder "bin" inside the mingw64 folder is in the path by again modifying the "Path" environment variable.  
+- OpenBLAS <https://github.com/OpenMathLib/OpenBLAS>. The 32 bit integer version is required. Either download OpenBLAS-*-x64.zip from the github releases or build from source via the commands
+cmake -B build -G Ninja -DBUILD_SHARED_LIBS=ON -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=PATH/TO/OpenBLAS/INTALL
+-cmake --build build --target install  
+
+Note: A build using MSVC, Intel ifx and MKL is possible, but suffered from strong memory leaks.  
+
 
 #### Python and Julia interfaces
-Download Python from (<https://www.python.org/downloads/>), guaranteed to include required libpython.dll
-
-### Steps:
-1. Activate the Intel oneAPI command prompt for Visual Studio 2022:  
-    Run `setvars.bat` located in:
-     ```
-     C:\Program Files (x86)\Intel\oneAPI
-     ```  
-    Search for intel oneAPI command prompt and run it.
-   
-2. Navigate to this folder and run CMake with the following commands:
-
-    ```  
-    cmake -B build -G Ninja -DCMAKE_BUILD_TYPE=Release [options]  
-    
-    cmake --build build  
-    ```
-
-3. See README.md for build options.
+Download Python from (<https://www.python.org/downloads/>). It should include the required libpython.dll and enable it being found. Microsoft store Python installations may result in libpython.dll not being found.
+
+blockSQP.jl does not require Julia to be installed. Julia 1.10 is recommended for testing and using it.
+
+
+### Building:
+In the command line, navigate to the blockSQP_2 folder and run the commands  
+&nbsp;&nbsp;&nbsp;&nbsp cmake -B build -G Ninja -DCMAKE_BUILD_TYPE=Release -DOPENBLAS_DIR=[*]  
+&nbsp;&nbsp;&nbsp;&nbsp cmake --build build  
+[*] must be the path to the OpenBLAS folder.  
+
+See README.md for build options.
diff --git a/benchmark/OCP_experiment.py b/benchmark/OCP_experiment.py
index 717300f..5eef3d5 100644
--- a/benchmark/OCP_experiment.py
+++ b/benchmark/OCP_experiment.py
@@ -25,7 +25,9 @@ import numpy as np
 import time
 import datetime
 import matplotlib.pyplot as plt
-plt.rcParams["text.usetex"] = True
+import shutil
+if shutil.which("latex") is not None:
+    plt.rcParams["text.usetex"] = True
 import casadi as cs
 
 
@@ -203,7 +205,10 @@ def plot_successful(n_EXP, nPert0, nPertF, titles, EXP_N_SQP, EXP_N_secs, EXP_ty
     
     fig = plt.figure(constrained_layout=True, dpi = 300, figsize = (14+2*(max(n_EXP - 2, 0)), 3.5 + 3.5*(n_EXP - 1)))
     if isinstance(suptitle, str):
-        fig.suptitle(r"$\textbf{" + suptitle + "}$", fontsize = 24, fontweight = 'bold')
+        if shutil.which("latex") is not None:
+            fig.suptitle(r"$\textbf{" + suptitle + "}$", fontsize = 24, fontweight = 'bold')
+        else:
+            fig.suptitle(suptitle, fontsize = 24, fontweight = 'bold')
     subfigs = fig.subfigures(nrows=n_EXP, ncols=1)
     
     if n_EXP == 1:
@@ -232,17 +237,14 @@ def plot_successful(n_EXP, nPert0, nPertF, titles, EXP_N_SQP, EXP_N_secs, EXP_ty
     if not isinstance(dirPath, Path):
         plt.show()
     else:
-        # if not os.path.exists(dirPath):
-        #     os.makedirs(dirPath)
         dirPath.mkdir(parents = True, exist_ok = True)
         
         date_app = str(datetime.datetime.now()).replace(" ", "_").replace(":", "_").replace(".", "_").replace("'", "")
         name_app = "" if suptitle is None else suptitle.replace(" ", "_").replace(":", "_").replace(".", "_").replace("'", "")        
-        # sep = "" if dirPath[-1] == "/" else "/"
         pref = "" if savePrefix is None else savePrefix
         
-        # plt.savefig(dirPath + sep + pref + "_it_s_" + name_app + "_" + date_app)
         plt.savefig(dirPath / Path(pref + "_it_s_" + name_app + "_" + date_app))
+    plt.close()
 
 def plot_varshape(n_EXP, nPert0, nPertF, titles, EXP_N_SQP, EXP_N_secs, EXP_type_sol, suptitle = None, dirPath : Path = None, savePrefix = None):
     if isinstance(dirPath, str):
@@ -285,7 +287,10 @@ def plot_varshape(n_EXP, nPert0, nPertF, titles, EXP_N_SQP, EXP_N_secs, EXP_type
 
     fig = plt.figure(constrained_layout=True, dpi = 300, figsize = (14+2*(max(n_EXP - 2, 0)), 3.5 + 3.5*(n_EXP - 1)))
     if isinstance(suptitle, str):
-        fig.suptitle(r"$\textbf{" + suptitle + "}$", fontsize = 24, fontweight = 'bold')
+        if shutil.which("latex") is not None:
+            fig.suptitle(r"$\textbf{" + suptitle + "}$", fontsize = 24, fontweight = 'bold')
+        else:
+            fig.suptitle(suptitle, fontsize = 24, fontweight = 'bold')
     subfigs = fig.subfigures(nrows=n_EXP, ncols=1)
     if n_EXP == 1:
         subfigs = (subfigs,)
@@ -328,6 +333,7 @@ def plot_varshape(n_EXP, nPert0, nPertF, titles, EXP_N_SQP, EXP_N_secs, EXP_type
         # sep = "" if dirPath[-1] == "/" else "/"
         pref = "" if savePrefix is None else savePrefix
         plt.savefig(dirPath / Path(pref + "_it_s_" + name_app + "_" + date_app))
+    plt.close()
 
 
 def plot_successful_small(n_EXP, nPert0, nPertF, titles, EXP_N_SQP, EXP_N_secs, EXP_type_sol, suptitle = None, dirPath : Path = None, savePrefix = None):
@@ -360,7 +366,10 @@ def plot_successful_small(n_EXP, nPert0, nPertF, titles, EXP_N_SQP, EXP_N_secs,
     fig, ax = plt.subplots(nrows = n_EXP, ncols = 2, constrained_layout=True, dpi = 300, figsize = (14+2*(max(n_EXP - 2, 0)), 2.5 + 2.5*(n_EXP - 1)))
     
     if isinstance(suptitle, str):
-        fig.suptitle(r"$\textbf{" + suptitle + "}$", fontsize = titlesize, fontweight = 'bold')
+        if shutil.which("latex") is not None:
+            fig.suptitle(r"$\textbf{" + suptitle + "}$", fontsize = titlesize, fontweight = 'bold')
+        else:
+            fig.suptitle(suptitle, fontsize = titlesize, fontweight = 'bold')
     for i in range(n_EXP):
         ax_it, ax_time = ax[i,:]
         ax_it.scatter(list(range(nPert0,nPertF)), EXP_N_SQP_S[i])
@@ -392,6 +401,7 @@ def plot_successful_small(n_EXP, nPert0, nPertF, titles, EXP_N_SQP, EXP_N_secs,
         pref = "" if savePrefix is None else savePrefix
         
         plt.savefig(dirPath / Path(pref + "_it_s_" + name_app + "_" + date_app))
+    plt.close()
 
 
 
diff --git a/benchmark/Paper_2025/Sect_3/P2Chem_Jacobian_condensing.py b/benchmark/Paper_2025/Sect_3/P2Chem_Jacobian_condensing.py
index 88bc50e..4409279 100644
--- a/benchmark/Paper_2025/Sect_3/P2Chem_Jacobian_condensing.py
+++ b/benchmark/Paper_2025/Sect_3/P2Chem_Jacobian_condensing.py
@@ -110,7 +110,7 @@ cond_args_nobounds.ub_con = M_ub_con
 #Condense a QP to obtain the condensed jacobian
 cond_nobounds.condense_args(cond_args_nobounds)
 
-#Optional: Solve both QPs and compare solution (-times)
+# Optional: Solve both QPs and compare the solution (-times)
 sys.stdout.flush()
 print("Solving the full QP and condensed QP (without implicit bounds), this may take up to half a minute ...")
 sys.stdout.flush()
@@ -134,7 +134,7 @@ cond_args_bounds.ub_con = M_ub_con
 #Condense with condenser that includes dependent variable bounds
 cond_bounds.condense_args(cond_args_bounds)
 
-#Optional: Solve both QPs and compare solution (-times)
+#Optional: Solve both QPs and compare the solution (-times)
 sys.stdout.flush()
 print("Solving the full QP and condensed QP (with implicit bounds), this may take up to half a minute ...")
 sys.stdout.flush()
diff --git a/benchmark/experiments/run_blockSQP_experiments.py b/benchmark/experiments/run_blockSQP_experiments.py
index 660ee49..0360f6a 100644
--- a/benchmark/experiments/run_blockSQP_experiments.py
+++ b/benchmark/experiments/run_blockSQP_experiments.py
@@ -21,16 +21,6 @@ except:
     cD = Path.cwd()
 sys.path += [str(cD.parent), str(cD.parents[1])]
 
-# import os
-# import sys
-# import datetime
-
-# try:
-#     cD = os.path.dirname(os.path.abspath(__file__))
-# except:
-#     cD = os.getcwd()
-# sys.path += [cD + "/..", cD + "/../.."]
-
 import py_blockSQP
 import OCP_experiment
 import OCProblems
@@ -38,12 +28,14 @@ import OCProblems
 
 Examples = [
             OCProblems.Batch_Reactor,
+<<<<<<< HEAD
+<<<<<<< HEAD
             # OCProblems.Cart_Pendulum,
-            # OCProblems.Catalyst_Mixing,
+            OCProblems.Catalyst_Mixing,
             # OCProblems.Cushioned_Oscillation,
             # OCProblems.Egerstedt_Standard,
             # OCProblems.Electric_Car,
-            # OCProblems.Goddard_Rocket,
+            OCProblems.Goddard_Rocket,
             # OCProblems.Hang_Glider,
             # OCProblems.Hanging_Chain,
             # OCProblems.Lotka_Volterra_Fishing,
@@ -53,6 +45,28 @@ Examples = [
             # OCProblems.Time_Optimal_Car,
             # OCProblems.Tubular_Reactor,
             # OCProblems.Lotka_OED,
+=======
+=======
+>>>>>>> 8ec9280091ae22946b043de0d110c2797171314a
+            OCProblems.Cart_Pendulum,
+            OCProblems.Catalyst_Mixing,
+            OCProblems.Cushioned_Oscillation,
+            OCProblems.Egerstedt_Standard,
+            OCProblems.Electric_Car,
+            OCProblems.Goddard_Rocket,
+            OCProblems.Hang_Glider,
+            OCProblems.Hanging_Chain,
+            OCProblems.Lotka_Volterra_Fishing,
+            OCProblems.Particle_Steering,
+            OCProblems.Quadrotor_Helicopter,
+            OCProblems.Three_Tank_Multimode,
+            OCProblems.Time_Optimal_Car,
+            OCProblems.Tubular_Reactor,
+            OCProblems.Lotka_OED,
+<<<<<<< HEAD
+>>>>>>> 8ec9280091ae22946b043de0d110c2797171314a
+=======
+>>>>>>> 8ec9280091ae22946b043de0d110c2797171314a
             ]
 OCProblems.Goddard_Rocket.__name__ = 'Goddard\'s Rocket'
 
@@ -86,13 +100,21 @@ opt_full.max_conv_QPs = 4
 opt_full.conv_strategy = 2
 opt_full.automatic_scaling = True
 
+opt_dense = py_blockSQP.SQPoptions()
+opt_dense.hess_approx = 2
+opt_dense.sizing = 4
+QPopts = py_blockSQP.qpOASES_options()
+QPopts.sparsityLevel = 2
+opt_dense.qpsol_options = QPopts
+
 #Select option sets to test for
 Experiments = [
                # (opt_SR1_BFGS, "SR1-BFGS"),
                # (opt_CS0, "Convexification strategy 0"),
                # (opt_CS1, "conv. str. 1"),
-               # (opt_CS2, "conv. str. 2")
-               (opt_full, "opt_full")
+               # (opt_CS2, "conv. str. 2"),
+               (opt_full, "opt_full"),
+               # (opt_dense, "opt_dense")
                ]
 
 
diff --git a/blockSQP/examples/example1.cpp b/blockSQP/examples/example1.cpp
index d8aa4ce..37ae89b 100644
--- a/blockSQP/examples/example1.cpp
+++ b/blockSQP/examples/example1.cpp
@@ -9,6 +9,10 @@
 #include "blocksqp_method.hpp"
 #include <limits>
 
+#define _CRTDBG_MAP_ALLOC
+#include <stdlib.h>
+#include <crtdbg.h>
+
 namespace blockSQP
 {
 
@@ -346,5 +350,7 @@ int main(int argc, const char* argv[]){
     delete stats;
     delete opts;
     delete meth;
+
+    _CrtDumpMemoryLeaks();
 }
 
diff --git a/blockSQP/examples/example1_sparse.cpp b/blockSQP/examples/example1_sparse.cpp
index f7c4a6d..ecf393d 100644
--- a/blockSQP/examples/example1_sparse.cpp
+++ b/blockSQP/examples/example1_sparse.cpp
@@ -178,7 +178,7 @@ void MyProblem::initialize( Matrix &xi, Matrix &lambda, Matrix &constrJac )
 void MyProblem::initialize( Matrix &xi, Matrix &lambda, double *jacNz, int *jacIndRow, int *jacIndCol )
 {   
     Matrix constrDummy, gradObjDummy, constrJac;
-    SymMatrix *hessDummy;
+    SymMatrix *hessDummy = nullptr;
     double objvalDummy;
     int info;
 
@@ -194,7 +194,7 @@ void MyProblem::initialize( Matrix &xi, Matrix &lambda, double *jacNz, int *jacI
     evaluate( xi, lambda, &objvalDummy, constrDummy, gradObjDummy, constrJac, hessDummy, 1, &info );
 
     // allocate sparse Jacobian structures
-    convertJacobian( constrJac, jacNz, jacIndRow, jacIndCol, 1 );
+    convertJacobian( constrJac, jacNz, jacIndRow, jacIndCol, 0 );
 }
 
 /*
diff --git a/blockSQP/src/blocksqp_matrix.cpp b/blockSQP/src/blocksqp_matrix.cpp
index fb6ce0c..5696c86 100644
--- a/blockSQP/src/blocksqp_matrix.cpp
+++ b/blockSQP/src/blocksqp_matrix.cpp
@@ -34,11 +34,7 @@
 #include <iostream>
 #include <string>
 #include <chrono>
-#ifdef WINDOWS
-    #include "mkl.h"
-#else
-    #include "cblas.h"
-#endif
+#include "cblas.h"
 //#define MATRIX_DEBUG      //Do bounds and dimension checking when performing matrix operations
 
 namespace blockSQP
@@ -87,8 +83,8 @@ int Matrix::free( void )
     if ( tflag )
         Error("free cannot be called with Submatrix");
 
-    if ( array != NULL )
-        delete[] array;
+    delete[] array;
+    array = nullptr;
 
     return 0;
 }
@@ -760,10 +756,8 @@ int SymMatrix::malloc(void){
 
 
 int SymMatrix::free(){
-    if (array != NULL){
-        delete[] array;
-        array = nullptr;
-    }
+    delete[] array;
+    array = nullptr;
     return 0;
 }
 
@@ -1997,9 +1991,7 @@ const Matrix &LT_Block_Matrix::operator() (int i, int j) const{
 	if (i >= j){
 		return array[i + j*m - (j*(j+1))/2];
 	}
-	else{
-		return Matrix(m_block_sizes[i], n_block_sizes[j]).Initialize(0.);
-	}
+    throw std::invalid_argument("Cannot access upper part of LT_Block_Matrix");
 }
 
 LT_Block_Matrix &LT_Block_Matrix::operator=(const LT_Block_Matrix &M){
diff --git a/py_blockSQP/__init__.py b/py_blockSQP/__init__.py
index b97ef63..6830cc7 100644
--- a/py_blockSQP/__init__.py
+++ b/py_blockSQP/__init__.py
@@ -1,9 +1,9 @@
 import os
 import sys
 if os.name == 'nt':
-	exe_dir = os.path.dirname(sys.executable)
-	dll_dir = os.path.join(exe_dir, f"python{sys.version_info.major}{sys.version_info.minor}.dll")
-	os.add_dll_directory(dll_dir)
+    exe_dir = os.path.dirname(sys.executable)
+    dll_dir = os.path.join(exe_dir, f"python{sys.version_info.major}{sys.version_info.minor}.dll")
+    os.add_dll_directory(dll_dir)
 try:
     from .py_blockSQP import *
 except ImportError as IERR:
diff --git a/py_blockSQP/py_blockSQP.cpp b/py_blockSQP/py_blockSQP.cpp
index e611fbe..b6f9215 100644
--- a/py_blockSQP/py_blockSQP.cpp
+++ b/py_blockSQP/py_blockSQP.cpp
@@ -65,7 +65,8 @@ template <typename T> class T_array{
     public:
     T_array(): size(0), ptr(nullptr){}
     T_array(int size_): size(size_), ptr(new T[size_]){} //Causes linker warning -Walloc-size-larger-than=
-
+    T_array(const T_array& arr): size(arr.size){ptr = new T[size]; std::copy(arr.ptr, arr.ptr + arr.size, ptr);}
+    T_array &operator=(const T_array& arr){delete[] ptr; size = arr.size; ptr = new T[size]; std::copy(arr.ptr, arr.ptr + arr.size, ptr); return *this;}
     ~T_array(){
         delete[] ptr;
     }
@@ -491,12 +492,14 @@ public:
     void set_blockIdx(py::array_t<int> arr){
         py::buffer_info buff = arr.request();
         nBlocks = buff.size - 1;
+        delete[] blockIdx;
         blockIdx = new int[buff.size];
         std::copy((int*)buff.ptr, (int*)buff.ptr + buff.size, blockIdx);
     }
     
     void set_vblocks(vblock_array &VB){
         n_vblocks = VB.size;
+        delete[] vblocks;
         vblocks = new blockSQP::vblock[n_vblocks];
         for (int i = 0; i < n_vblocks; i++){
             vblocks[i] = VB.ptr[i];
@@ -1002,7 +1005,7 @@ py::class_<blockSQP::Condenser>(m, "Condenser")
             );
             steady_clock::time_point T1 = steady_clock::now();
             std::cout << "Condensing took " << duration_cast<milliseconds>(T1 - T0) << "\n";
-            args.condensed_hess.size = C.condensed_num_hessblocks;
+            //args.condensed_hess.size = C.condensed_num_hessblocks;
             return;})
     .def_readonly("num_hessblocks", &blockSQP::Condenser::num_hessblocks)
     .def_readonly("num_vars", &blockSQP::Condenser::num_vars)
